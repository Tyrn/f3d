/*
 * This is not a legitimate C file.
 * Not for compilation!
 *
 * Step by step guide for implementing VCP
 * circular buffer (and console echo).
 * Blog posts on nefastor.com
 *
 */

// Core/Src/main.c:
...
/* USER CODE BEGIN Includes */
#include "usbd_cdc_if.h"
/* USER CODE END Includes */
...
  /* USER CODE BEGIN WHILE */
  uint8_t buf[1000];
  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
    // VCP demonstration - Echo all data received over VCP back to the host
    int len = vcp_recv (buf, 1000);  // Read up to 1000 bytes
    if (len > 0)    // If some data was read, send it back :
      len = vcp_send (buf, len);
  }
  /* USER CODE END 3 */
...

// USB_DEVICE/App/usbd_cdc_if.h:
...
/* USER CODE BEGIN EXPORTED_DEFINES */
/* Define size for the receive and transmit buffer over CDC */
#define APP_RX_DATA_SIZE  1000
#define APP_TX_DATA_SIZE  1000
#define RX_BUFFER_MAX_WRITE_INDEX (APP_RX_DATA_SIZE - CDC_DATA_FS_MAX_PACKET_SIZE)
/* USER CODE END EXPORTED_DEFINES */
...
/* USER CODE BEGIN EXPORTED_TYPES */

 typedef struct VCP_FIFO_TYPE
 {
   uint8_t* data;  // Will point to the Cube-generated Tx or Rx buffer
   int  wr;    // Write index
   int  rd;    // Read index
   int  lb;    // Additional index
 } VCP_FIFO;

/* USER CODE END EXPORTED_TYPES */
...
/* USER CODE BEGIN EXPORTED_FUNCTIONS */
int vcp_send(uint8_t* buf, uint16_t len);
int vcp_recv(uint8_t* buf, uint16_t len);
void vcp_service();
/* USER CODE END EXPORTED_FUNCTIONS */
...

// USB_DEVICE/App/usbd_cdc_if.c:
...
/* USER CODE BEGIN PRIVATE_VARIABLES */

// Circular FIFO to store outgoing data until it can be sent over USB
VCP_FIFO vcp_tx_fifo;
// Circular FIFO to store incoming data from the host over USB
VCP_FIFO vcp_rx_fifo;

/* USER CODE END PRIVATE_VARIABLES */
...
static int8_t CDC_Init_FS(void)
{
  /* USER CODE BEGIN 3 */
    // Circular FIFO initializations :
  vcp_tx_fifo.data = UserTxBufferFS;  // Use the buffer generated by Cube
  vcp_tx_fifo.wr = 0;
  vcp_tx_fifo.rd = 0;
  vcp_tx_fifo.lb = 0;
  vcp_rx_fifo.data = UserRxBufferFS;  // Use the buffer generated by Cube
  vcp_rx_fifo.wr = 0;
  vcp_rx_fifo.rd = 0;
  vcp_rx_fifo.lb = 0;

  /* Set Application Buffers */
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, UserTxBufferFS, 0);
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, UserRxBufferFS);
  return (USBD_OK);
  /* USER CODE END 3 */
}
...
static int8_t CDC_Receive_FS(uint8_t* Buf, uint32_t *Len)
{
  /* USER CODE BEGIN 6 */
  // Update the write index for the next incoming packet
  vcp_rx_fifo.wr += *Len;
  // Is the new value too close to the end of the FIFO ?
  if (vcp_rx_fifo.wr >= RX_BUFFER_MAX_WRITE_INDEX)
  {
    // Solution : wrap-around (and save wr as lb)
    vcp_rx_fifo.lb = vcp_rx_fifo.wr;
    vcp_rx_fifo.wr = 0;
  }
  // Tell the driver where to write the next incoming packet
  USBD_CDC_SetRxBuffer(&hUsbDeviceFS, vcp_rx_fifo.data + vcp_rx_fifo.wr);
  // Receive the next packet
  USBD_CDC_ReceivePacket(&hUsbDeviceFS);
  return (USBD_OK);
  /* USER CODE END 6 */
}
...
uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len)
{
  uint8_t result = USBD_OK;
  /* USER CODE BEGIN 7 */
  USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
  if (hcdc->TxState != 0){
    return USBD_BUSY;
  }
  USBD_CDC_SetTxBuffer(&hUsbDeviceFS, Buf, Len);
  result = USBD_CDC_TransmitPacket(&hUsbDeviceFS);
  /* USER CODE END 7 */
  return result;
}

/* USER CODE BEGIN PRIVATE_FUNCTIONS_IMPLEMENTATION */

int vcp_send(uint8_t* buf, uint16_t len)
{
  // Step 1 : calculate the occupied space in the Tx FIFO
  int cap = vcp_tx_fifo.wr - vcp_tx_fifo.rd;   // occupied capacity
  if (cap < 0)    // FIFO contents wrap around
    cap += APP_TX_DATA_SIZE;
  cap = APP_TX_DATA_SIZE - cap;      // available capacity
  // Step 2 : compare with argument
  if (cap < len)
    return -1;   // Not enough room to copy "buf" into the FIFO => error
  // Step 3 : does buf fit in the tail ?
  int tail = APP_TX_DATA_SIZE - vcp_tx_fifo.wr;
  if (tail >= len)
  {
    // Copy buf into the tail of the FIFO
    memcpy (&vcp_tx_fifo.data[vcp_tx_fifo.wr], buf, len);
    // Update "wr" index
    vcp_tx_fifo.wr += len;
    // In case "len" == "tail", next write goes to the head
    if (vcp_tx_fifo.wr == APP_TX_DATA_SIZE)
      vcp_tx_fifo.wr = 0;
  }
  else
  {
    // Copy the head of "buf" to the tail of the FIFO
    memcpy (&vcp_tx_fifo.data[vcp_tx_fifo.wr], buf, tail);
    // Copy the tail of "buf" to the head of the FIFO :
    memcpy (vcp_tx_fifo.data, &buf[tail], len - tail);
    // Update the "wr" index
    vcp_tx_fifo.wr = len - tail;
  }
  return 0;  // successful completion
}

int vcp_recv(uint8_t* buf, uint16_t len)
{
  // Compute how much data is in the FIFO
  int cap = vcp_rx_fifo.wr - vcp_rx_fifo.rd;
  if (cap == 0)
    return 0;      // Empty FIFO, no data to read
  if (cap < 0)  // FIFO contents wrap around
    cap += vcp_rx_fifo.lb;  // Notice the use of lb
  // Limit the FIFO read to the available data
  if (len > cap)
    len = cap;
  // Save len : it'll be the return value
  int retval = len;
  // Read the data
  while (len)
  {
    len--;
    *buf = vcp_rx_fifo.data[vcp_rx_fifo.rd];
    buf++;
    vcp_rx_fifo.rd++;    // Update read index
    if (vcp_rx_fifo.rd == vcp_rx_fifo.lb)  // Check for wrap-around
      vcp_rx_fifo.rd = 0;      // Follow wrap-around
  }
  return retval;
}

void vcp_service()
{
USBD_CDC_HandleTypeDef *hcdc = (USBD_CDC_HandleTypeDef*)hUsbDeviceFS.pClassData;
  // Test if the USB CDC is ready to transmit
  if (hcdc->TxState == 0)
  {
    // Update the FIFO to reflect the completion of the last transmission
    vcp_tx_fifo.rd = vcp_tx_fifo.lb;
    // Compute how much data is in the FIFO
    int cap = vcp_tx_fifo.wr - vcp_tx_fifo.rd;
    if (cap != 0)  // The FIFO is empty : return immediately
    {
      if (cap < 0)  // The FIFO contents wrap-around
      {
        // Send only the tail of the FIFO
        USBD_CDC_SetTxBuffer(&hUsbDeviceFS, &vcp_tx_fifo.data[vcp_tx_fifo.rd], APP_TX_DATA_SIZE - vcp_tx_fifo.rd);
        USBD_CDC_TransmitPacket(&hUsbDeviceFS);
        vcp_tx_fifo.lb = 0;    // Lock the tailâ€™s data
      }
      else  // No wrap-around : send the whole FIFO
      {
        USBD_CDC_SetTxBuffer(&hUsbDeviceFS, &vcp_tx_fifo.data[vcp_tx_fifo.rd], cap);
        USBD_CDC_TransmitPacket(&hUsbDeviceFS);
        vcp_tx_fifo.lb = vcp_tx_fifo.wr; // lock the data
      }
    }
  }
}

/* USER CODE END PRIVATE_FUNCTIONS_IMPLEMENTATION */
...

// Core/Src/stm32f3xx_it.c:
...
/* USER CODE BEGIN Includes */
#include "usbd_cdc_if.h"
/* USER CODE END Includes */
...
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
  /* USER CODE BEGIN SysTick_IRQn 1 */
  // USB VCP library : background processing of data transmission
  vcp_service();
  /* USER CODE END SysTick_IRQn 1 */
}
...
